I need you to build an arcade games collection website with three classic games: a brick breaker called Brickrush, a sliding tile puzzle called 1024, and Snake. This should be a polished, production-ready React application that works beautifully on both desktop and mobile devices.

For the tech stack, use React 18 with Vite as the build tool, Tailwind CSS for styling, and Vitest for testing. The brick breaker and snake games should render on HTML5 Canvas, while the 1024 game can use regular DOM elements with CSS animations. You'll also want react-icons for the UI icons.

The visual design should follow a dark glassmorphism aesthetic. Think deep black backgrounds with semi-transparent panels that have backdrop blur effects, subtle borders, and soft glowing shadows. Each game gets its own accent color: cyan for Brickrush, amber for 1024, and green for Snake. Use pink as a highlight color throughout. The backgrounds should have these subtle animated gradient orbs that pulse slowly, giving the interface some life without being distracting. Use the Raleway font and create animated gradient text effects for the main titles that cycle through the accent colors.

When someone first loads the app, show them a loading screen for about three and a half seconds with an animated title, a spinning loader, and a progress bar. After that fades out, they land on a game selector screen. This is a simple hub with cards for each game showing a custom icon, the game name, a short description, and some category tags. The cards should have nice hover effects with glowing borders in the game's accent color. Let users press 1, 2, or 3 on their keyboard to quickly jump into a game.
You'll want to build a set of shared menu components that all three games can use. Create a start menu overlay that shows the game title, a description, and buttons to start playing or see how to play. Build a pause menu with options to resume, restart, or go back to the main menu. The pause menu should also support an optional speed control for games that need it. Create a game-over screen that displays the final score, high score, and any relevant stats, with buttons to play again or return to the menu. And create a how-to-play modal that shows instructions, a controls table, and some tips. All these menus should fade in and out smoothly, support keyboard navigation, and look consistent across all games while accepting different accent colors.
Wrap the entire application and each individual game in error boundaries. If something crashes, show a friendly error screen with options to retry or go back to the menu instead of just breaking completely. Only show technical error details in development mode.

For the games themselves, here's what each one needs:
Brickrush is your classic breakout game. The play area should be 800 by 600 pixels at a 4:3 aspect ratio, scaling responsively to fit different screens. The player controls a paddle at the bottom to bounce a ball upward and destroy bricks. Start with three lives and lose one whenever the ball falls below the paddle. Include eight different levels with unique brick patterns like pyramids, diamonds, castles, and checkerboards. Some bricks should be steel gray and indestructible, just bouncing the ball back. Add power-ups that fall from certain bricks when destroyed: one that spawns extra balls and one that temporarily makes the paddle wider. On desktop, the paddle should follow the mouse cursor or respond to arrow keys. On mobile, players drag to move the paddle and tap to launch the ball. Points should be ten times the current level for each brick destroyed.

The 1024 game is a sliding tile puzzle on a 4Ã—4 grid. Tiles slide in the direction you swipe or press, and when two tiles with the same number collide, they merge into one tile with double the value. Start with two random tiles, either 2s or 4s. After each move, spawn a new tile in an empty spot. The goal is to create a 1024 tile, at which point you show a congratulations screen but let the player keep going if they want. The game ends when the grid is full and no moves are possible. Each tile value needs its own color scheme, progressing from cool blues for low numbers through teals and oranges for medium values to pinks for high values, with the 1024 tile being a special cyan color. Animate the tiles sliding smoothly and add a satisfying pop effect when they merge. Support arrow keys and WASD on desktop, swipe gestures on mobile.

Snake is the classic game where you guide a growing snake to eat food while avoiding walls and your own tail. Use a 20 by 20 grid with cells that are 20 pixels each. The snake starts with three segments and moves continuously in the current direction. Regular food appears as pink dots worth ten points, and occasionally golden bonus food appears worth fifty points. The snake should speed up as the score increases, starting at 150 milliseconds per move and getting as fast as 60 milliseconds. On desktop use arrow keys or WASD, and include a pause toggle with P or Space. On mobile, support swipe gestures but also show a D-pad with directional buttons below the game canvas since swipe controls can be tricky during fast gameplay. Make sure players can't instantly reverse direction into themselves.

Build custom React hooks to handle common functionality across the games. You'll need a game loop hook that manages requestAnimationFrame with proper delta time calculations. A high score hook that persists scores to localStorage safely. A keyboard hook for handling input with configurable key mappings. A window size hook that tracks the viewport and provides breakpoint flags for responsive logic. A game state machine hook to manage transitions between states like start, playing, paused, and game over. And a controls hook that unifies keyboard and touch input including swipe detection.
Each game should have its own hook that encapsulates all the game logic and state, keeping the rendering components clean. These hooks expose the current game data, handlers for user input, and methods to control the game flow.

Store high scores in localStorage with graceful error handling for edge cases like private browsing. Each game gets its own storage key.
Write tests for the utility functions, custom hooks, and shared components. Include tests for critical game flows. Set up a CI pipeline that runs the linter, tests, and build on pull requests and pushes, uploading build artifacts for PR previews. Add a CD pipeline that deploys to production via SSH when changes land on the main branch.
Make sure the app is accessible. Use proper ARIA labels, trap focus inside modals, support full keyboard navigation, respect the user's reduced motion preferences, maintain good color contrast, and announce important game state changes for screen readers. Touch targets on mobile should be at least 44 pixels.
Keep performance in mind throughout. Use requestAnimationFrame for game loops, memoize where it helps, lazy load the game components, and keep the bundle size reasonable. Optimize canvas rendering to avoid unnecessary redraws.
Write clean, well-organized code with helpful comments explaining any non-obvious logic. Use PropTypes or TypeScript for type safety. Configure ESLint and Prettier for consistent formatting.
The final deliverable should be a complete, polished application that's genuinely fun to play. Include a comprehensive README explaining how to set up and run the project, document the controls for each game, and provide a brief architecture overview. Add a contributing guide and MIT license.